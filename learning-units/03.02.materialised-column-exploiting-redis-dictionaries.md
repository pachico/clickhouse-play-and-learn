# Materialised column exploiting Redis dictionary

> 💡 Instructions about how to use this project can be found [here](../README.md).

Redis is a great product and we can use it as dictionary source too.  
We have already learned the basics about dictionaries, so this unit will simply describe how to connect to Redis and exploit its connectivity.

https://clickhouse.tech/docs/en/sql-reference/dictionaries/external-dictionaries/external-dicts-dict-sources/#dicts-external_dicts_dict_sources-redis

- [Materialised column exploiting Redis dictionary](#materialised-column-exploiting-redis-dictionary)
  - [Our use case](#our-use-case)
  - [Redis data](#redis-data)
  - [ClickHouse schema](#clickhouse-schema)
  - [Seeing it in action](#seeing-it-in-action)
  - [Wrapping up](#wrapping-up)

## Our use case

We are a stock broker company. Our clients buy and sell stocks and we want to track how much money these operations involve but the stock prices change really quickly!  

We will solve this by having the stock values in Redis and, whenever we want to register a stock sell or purchase, we will check the current stock price and save it in our ClickHouse table.  
For this demo, we will track stocks for the fictitious `Django Tech Inc. (DGT)` and `Sibelius Corp. (SBL)` companies.

## Redis data

Redis is already up in running when you started this project so we can already store the stock values:

```bash
docker-compose exec redis ash -c "redis-cli MSET DGT 200.00 SBL 300.00"
```

Let's see if they were stored correctly by doing:

```bash
docker-compose exec redis ash -c "redis-cli MGET DGT SBL"
```

## ClickHouse schema

Let's create a db for this. In ClickHouse type:

```sql
CREATE DATABASE IF NOT EXISTS stock;
```

```sql
use stock;
```

Now let's create the dictionary that will fetch data from Redis:

```sql
CREATE DICTIONARY IF NOT EXISTS stock_value
(
    stock String,
    value Float32
)
PRIMARY KEY stock
SOURCE(REDIS(
    host 'redis'
    port 6379
    storage_type 'simple'
    db_index 0
))
LAYOUT(COMPLEX_KEY_HASHED())
LIFETIME(5);
```

Let's see if we can fetch data from this dictionary:

```sql
SELECT dictGetFloat32('stock.stock_value', 'value', tuple('SBL'));
```

And now we create the table that will store the transactions:

```sql
CREATE TABLE stock_exchange 
(
    timestamp DateTime,
    client_id UInt32,
    stock LowCardinality(String),
    amount Int32,
    value Float32 MATERIALIZED amount * dictGetFloat32('stock.stock_value', 'value', tuple(stock))
) 
ENGINE = MergeTree()
ORDER BY timestamp;
```

This is mostly a regular table but the column `value` exploits the Redis dictionary by multiplying the amount of stocks (`amount`) by the current value of the stock using `dictGetFloat32('stock.stock_value', 'value', tuple(stock))`.

## Seeing it in action

Our client with id `1` is buying `3` `SBL` stocks and client with id `2` is buying `10` `DGT` . Let's record it.

```sql
INSERT INTO stock_exchange VALUES
    (now(), 1, 'SBL', 3),
    (now(), 2, 'DGT', 10)
    ;
```

Let's see what has been recorded:

```sql
SELECT *, value FROM stock_exchange;

┌───────────timestamp─┬─client_id─┬─stock─┬─amount─┬─value─┐
│ 2021-07-14 07:24:54 │         1 │ SBL   │      3 │   900 │
│ 2021-07-14 07:24:54 │         2 │ DGT   │     10 │  2000 │
└─────────────────────┴───────────┴───────┴────────┴───────┘

```

(Remember that the column `value`, by being materialised, is excluded when using the asterisk `*`.)

Great, it seems to work.

Now let's change the stock values with:

```bash
docker-compose exec redis ash -c "redis-cli MSET DGT 20.00 SBL 30.00"
```

and register more transactions:

```sql
INSERT INTO stock_exchange VALUES
    (now(), 1, 'SBL', -1),
    (now(), 2, 'DGT', -2)
    ;

```

And check the records again:

```sql
SELECT *, value FROM stock_exchange;
```

## Wrapping up

As you can see, this is a powerful way to use data that is frequently changes, like currency exchange rates, ratings, etc.

To clean everything up, just delete the database:

```sql
DROP DATABASE stock;
```